import { GoogleGenAI, Type } from "@google/genai";
import { ComponentSpec } from "../types";

/**
 * Creates a fresh Gemini client instance.
 * MUST be called inside functions to ensure it picks up the latest process.env.API_KEY
 * which might be injected after user selection.
 */
const getAiClient = () => {
  // @ts-ignore
  return new GoogleGenAI({ apiKey: process.env.API_KEY });
};

/**
 * Refines a rough sketch into a professional diagram using 'gemini-3-pro-image-preview' (Nano Banana Pro).
 */
export const refineSketch = async (base64Images: string[]): Promise<string> => {
  const ai = getAiClient();

  // Prepare all images
  const imageParts = base64Images.map(img => ({
    inlineData: {
      mimeType: 'image/png',
      data: img.replace(/^data:image\/\w+;base64,/, "")
    }
  }));

  try {
    const response = await ai.models.generateContent({
      model: 'gemini-3-pro-image-preview',
      contents: {
        parts: [
          {
            text: `
            Role: Expert Technical Illustrator & Software Architect Task: Synthesize multiple hand-drawn sketches (overview and sub-components) into a single, professional, high-fidelity software architecture diagram.

            Visual Style Guidelines:

            Aesthetic: Modern, clean, flat vector art style similar to high-end SaaS documentation (e.g., Stripe, AWS, Datadog docs).

            Perspective: 2D Orthogonal (flat) or clean Isometric.

            Color Palette: Professional corporate palette. Use cool blues, neutral greys, and crisp white backgrounds. Use distinct accent colors (e.g., green/orange) strictly for status or emphasis.

            Line Work: Uniform line weights, rounded corners on containers, and orthogonal (right-angle) connector lines.

            Composition & Structure:

            Layout: Unified system view. Place the "Overview" components centrally, with "Sub-components" expanded logically around the core or nested within their respective parent containers.

            Symbology: Use standard industry conventions:

              Databases: Cylinders.

              Services/Apps: Rectangles/Rounded Squares.

              External/Internet: Cloud shapes.

              Users/Actors: Stick figures or standard user icons.

            Clarity: Ensure high contrast between text labels (if generated) and background. Avoid clutter; prioritize whitespace for readability.
            
            `,
          },
          ...imageParts,
        ],
      },
      config: {
        imageConfig: {
          aspectRatio: "16:9", // Widescreen for diagrams
          imageSize: "2K", // High quality
        },
      },
    });

    // Extract the generated image
    for (const part of response.candidates?.[0]?.content?.parts || []) {
      if (part.inlineData && part.inlineData.data) {
        return `data:image/png;base64,${part.inlineData.data}`;
      }
    }

    throw new Error("No image generated by the model.");
  } catch (error) {
    console.error("Refinement error:", error);
    throw error;
  }
};

/**
 * Analyzes the refined diagram to extract component specifications using 'gemini-3-pro-preview'.
 */
export const analyzeDiagramComponents = async (base64Image: string): Promise<ComponentSpec[]> => {
  const ai = getAiClient();
  const base64Data = base64Image.replace(/^data:image\/\w+;base64,/, "");

  try {
    const response = await ai.models.generateContent({
      model: 'gemini-3-pro-preview',
      contents: {
        parts: [
          {
            text: "Analyze this software architecture diagram. Identify the key software components, modules, databases, and actors. Return a JSON list of these components with a name and a brief description of their likely role based on standard architectural patterns.",
          },
          {
            inlineData: {
              mimeType: 'image/png',
              data: base64Data,
            },
          },
        ],
      },
      config: {
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.ARRAY,
          items: {
            type: Type.OBJECT,
            properties: {
              name: { type: Type.STRING },
              description: { type: Type.STRING },
            },
            required: ["name", "description"],
          },
        },
      },
    });

    const text = response.text;
    if (!text) throw new Error("No text response from model");

    const rawComponents = JSON.parse(text);

    // Map to our internal type with IDs
    return rawComponents.map((c: any, index: number) => ({
      id: `comp-${index}-${Date.now()}`,
      name: c.name,
      description: c.description,
      userNotes: "", // Initialized empty for user input
    }));

  } catch (error) {
    console.error("Analysis error:", error);
    throw error;
  }
};

/**
 * Generates the final build plan using 'gemini-3-pro-preview'.
 */
export const generateBuildPlan = async (
  refinedDiagramBase64: string,
  specs: ComponentSpec[]
): Promise<string> => {
  const ai = getAiClient();
  const base64Data = refinedDiagramBase64.replace(/^data:image\/\w+;base64,/, "");

  const specsText = specs.map(s =>
    `- Component: ${s.name}\n  inferred Role: ${s.description}\n  User Requirements: ${s.userNotes || "None provided"}`
  ).join("\n\n");

  const prompt = `
    You are a world-class Senior Software Architect.
    
    Based on the attached architecture diagram and the following detailed component specifications, create a comprehensive Implementation Plan.
    
    The plan MUST include:
    1. **Project Overview**: Brief summary of the system.
    2. **Tech Stack Recommendation**: Best languages, frameworks, and databases for this specific architecture.
    3. **Detailed Component Implementation**: For each component, explain how to build it, what libraries to use, and how it connects to others.
    4. **API Strategy**: Define key endpoints or communication protocols (REST, GraphQL, gRPC, etc.).
    5. **Folder Structure**: A suggested file tree for the project.
    6. **Step-by-Step Build Guide**: A numbered list of steps to go from zero to MVP.

    **Component Specifications:**
    ${specsText}
  `;

  try {
    const response = await ai.models.generateContent({
      model: 'gemini-3-pro-preview',
      contents: {
        parts: [
          { text: prompt },
          {
            inlineData: {
              mimeType: 'image/png',
              data: base64Data,
            },
          },
        ],
      },
    });

    return response.text || "Failed to generate plan.";
  } catch (error) {
    console.error("Build Plan error:", error);
    throw error;
  }
};

/**
 * Process a version in the background (refine + analyze).
 * This chains the refinement and analysis steps together with progress callbacks.
 */
export const processVersionInBackground = async (
  images: string[],
  onProgress: (status: 'refining' | 'specifying' | 'complete') => void
): Promise<{ refinedImage: string; specs: ComponentSpec[] }> => {
  // Filter out null/empty images
  const validImages = images.filter(Boolean);

  if (validImages.length === 0) {
    throw new Error("No valid images to process");
  }

  // Step 1: Refine the sketches
  onProgress('refining');
  const refinedImage = await refineSketch(validImages);

  // Step 2: Analyze components from the refined image
  onProgress('specifying');
  const specs = await analyzeDiagramComponents(refinedImage);

  // Done
  onProgress('complete');
  return { refinedImage, specs };
};

